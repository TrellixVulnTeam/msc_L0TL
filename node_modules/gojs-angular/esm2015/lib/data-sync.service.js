/**
 * @fileoverview added by tsickle
 * Generated from: lib/data-sync.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Injectable } from '@angular/core';
import * as go from 'gojs';
export class DataSyncService {
    constructor() { }
    /**
     * Sync a node data array with a set of changes
     * @param {?} changes The set of changes to the GoJS model
     * @param {?} nodeData The node data array to merge these changes with
     * @param {?=} model Required if you have defined your model.nodeKeyProperty to be something other than 'key'
     * @return {?} A node data array, merged with the changes
     */
    static syncNodeData(changes, nodeData, model) {
        if (!changes)
            return nodeData;
        if (!changes.modifiedNodeData && !changes.insertedNodeKeys && !changes.removedNodeKeys)
            return nodeData;
        // maintain a map of modified nodes for fast lookup during insertion
        /** @type {?} */
        const modifiedNodesMap = new go.Map();
        // account for modified node data
        if (changes.modifiedNodeData) {
            changes.modifiedNodeData.forEach((/**
             * @param {?} nd
             * @return {?}
             */
            (nd) => {
                // Get the value of the node key property checking wether is a function or a string
                /** @type {?} */
                const key = model ? model.getKeyForNodeData(nd) : nd['key'];
                modifiedNodesMap.set(key, nd);
                for (let i = 0; i < nodeData.length; i++) {
                    /** @type {?} */
                    const ndEntry = nodeData[i];
                    /** @type {?} */
                    const keyNdEntry = model ? model.getKeyForNodeData(ndEntry) : ndEntry['key'];
                    if (keyNdEntry === key) {
                        nodeData[i] = nd;
                    }
                }
            }));
        }
        // account for inserted node data
        if (changes.insertedNodeKeys) {
            changes.insertedNodeKeys.forEach((/**
             * @param {?} key
             * @return {?}
             */
            (key) => {
                /** @type {?} */
                const nd = modifiedNodesMap.get(key);
                if (nd) {
                    nodeData.push(nd);
                }
            }));
        }
        // account for removed node data
        if (changes.removedNodeKeys) {
            nodeData = nodeData.filter((/**
             * @param {?} nd
             * @return {?}
             */
            (nd) => {
                /** @type {?} */
                const key = model ? model.getKeyForNodeData(nd) : nd['key'];
                if (changes.removedNodeKeys.includes(key)) {
                    return false;
                }
                return true;
            }));
        }
        return nodeData;
    }
    /**
     * Sync a link data array with a set of changes
     * @param {?} changes The set of changes to the GoJS model
     * @param {?} linkData The link data array to merge these changes with
     * @param {?=} model Required if you have defined your model.linkKeyProperty to be something other than 'key'
     * @return {?} A link data array, merged with the changes
     */
    static syncLinkData(changes, linkData, model) {
        if (!changes)
            return linkData;
        if (!changes.modifiedLinkData && !changes.insertedLinkKeys && !changes.removedLinkKeys)
            return linkData;
        // maintain a map of modified nodes for fast lookup during insertion
        /** @type {?} */
        const modifiedLinksMap = new go.Map();
        // account for modified link data
        if (changes.modifiedLinkData) {
            changes.modifiedLinkData.forEach((/**
             * @param {?} ld
             * @return {?}
             */
            (ld) => {
                // Get the value of the link key
                /** @type {?} */
                const key = model ? model.getKeyForLinkData(ld) : ld['key'];
                modifiedLinksMap.set(key, ld);
                for (let i = 0; i < linkData.length; i++) {
                    /** @type {?} */
                    const ldEntry = linkData[i];
                    /** @type {?} */
                    const keyLdEntry = model ? model.getKeyForLinkData(ldEntry) : ldEntry['key'];
                    if (keyLdEntry === key) {
                        linkData[i] = ld;
                    }
                }
            }));
        }
        // account for inserted link data
        if (changes.insertedLinkKeys) {
            changes.insertedLinkKeys.forEach((/**
             * @param {?} key
             * @return {?}
             */
            (key) => {
                /** @type {?} */
                const nd = modifiedLinksMap.get(key);
                if (nd) {
                    linkData.push(nd);
                }
            }));
        }
        // account for removed link data
        if (changes.removedLinkKeys) {
            linkData = linkData.filter((/**
             * @param {?} ld
             * @return {?}
             */
            (ld) => {
                /** @type {?} */
                const key = model ? model.getKeyForLinkData(ld) : ld['key'];
                if (changes.removedLinkKeys.includes(key)) {
                    return false;
                }
                return true;
            }));
        }
        return linkData;
    }
    /**
     * Sync modelData with a set of changes
     * @param {?} changes The set of changes to the GoJS model
     * @param {?} modelData The modelData to merge these changes with
     * @return {?} A modelData object, merged with the changes
     */
    static syncModelData(changes, modelData) {
        if (!changes)
            return modelData;
        if (!changes.modelData)
            return modelData;
        if (changes.modelData) {
            return changes.modelData;
        }
    }
}
DataSyncService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
DataSyncService.ctorParameters = () => [];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0YS1zeW5jLnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wcm9qZWN0cy9nb2pzLWFuZ3VsYXIvc3JjL2xpYi9kYXRhLXN5bmMuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxLQUFLLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFHM0IsTUFBTSxPQUFPLGVBQWU7SUFFMUIsZ0JBQWdCLENBQUM7Ozs7Ozs7O0lBU1YsTUFBTSxDQUFDLFlBQVksQ0FBQyxPQUEyQixFQUFFLFFBQThCLEVBQUUsS0FBZ0I7UUFDdEcsSUFBSSxDQUFDLE9BQU87WUFBRSxPQUFPLFFBQVEsQ0FBQztRQUM5QixJQUFJLENBQUMsT0FBTyxDQUFDLGdCQUFnQixJQUFJLENBQUMsT0FBTyxDQUFDLGdCQUFnQixJQUFJLENBQUMsT0FBTyxDQUFDLGVBQWU7WUFBRSxPQUFPLFFBQVEsQ0FBQzs7O2NBR2xHLGdCQUFnQixHQUFHLElBQUksRUFBRSxDQUFDLEdBQUcsRUFBeUI7UUFFNUQsaUNBQWlDO1FBQ2pDLElBQUksT0FBTyxDQUFDLGdCQUFnQixFQUFFO1lBQzVCLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPOzs7O1lBQUMsQ0FBQyxFQUFpQixFQUFFLEVBQUU7OztzQkFFL0MsR0FBRyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLGlCQUFpQixDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDO2dCQUMzRCxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxDQUFDO2dCQUM5QixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsUUFBUSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTs7MEJBQ2xDLE9BQU8sR0FBRyxR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LENBQUMsR0FBVyxFQUFFLEVBQUU7O3NCQUN6QyxFQUFFLEdBQUcsZ0JBQWdCLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQztnQkFDcEMsSUFBSSxFQUFFLEVBQUU7b0JBQ04sUUFBUSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztpQkFDbkI7WUFDSCxDQUFDLEVBQUMsQ0FBQztTQUNKO1FBRUQsZ0NBQWdDO1FBQ2hDLElBQUksT0FBTyxDQUFDLGVBQWUsRUFBRTtZQUMzQixRQUFRLEdBQUcsUUFBUSxDQUFDLE1BQU07Ozs7WUFBQyxDQUFDLEVBQWlCLEVBQUUsRUFBRTs7c0JBQ3pDLEdBQUcsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQztnQkFDM0QsSUFBSSxPQUFPLENBQUMsZUFBZSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsRUFBRTtvQkFDekMsT0FBTyxLQUFLLENBQUM7aUJBQ2Q7Z0JBQUMsT0FBTyxJQUFJLENBQUM7WUFDaEIsQ0FBQyxFQUFDLENBQUM7U0FDSjtRQUVELE9BQU8sUUFBUSxDQUFDO0lBQ2xCLENBQUM7Ozs7Ozs7SUFRTSxNQUFNLENBQUMsYUFBYSxDQUFDLE9BQTJCLEVBQUUsU0FBd0I7UUFDL0UsSUFBSSxDQUFDLE9BQU87WUFBRSxPQUFPLFNBQVMsQ0FBQztRQUMvQixJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVM7WUFBRSxPQUFPLFNBQVMsQ0FBQztRQUN6QyxJQUFJLE9BQU8sQ0FBQyxTQUFTLEVBQUU7WUFDckIsT0FBTyxPQUFPLENBQUMsU0FBUyxDQUFDO1NBQzFCO0lBQ0gsQ0FBQzs7O1lBNUhGLFVBQVUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCAqIGFzIGdvIGZyb20gJ2dvanMnO1xyXG5cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgRGF0YVN5bmNTZXJ2aWNlIHtcclxuXHJcbiAgY29uc3RydWN0b3IoKSB7IH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3luYyBhIG5vZGUgZGF0YSBhcnJheSB3aXRoIGEgc2V0IG9mIGNoYW5nZXNcclxuICAgKiBAcGFyYW0gY2hhbmdlcyBUaGUgc2V0IG9mIGNoYW5nZXMgdG8gdGhlIEdvSlMgbW9kZWxcclxuICAgKiBAcGFyYW0gbm9kZURhdGEgVGhlIG5vZGUgZGF0YSBhcnJheSB0byBtZXJnZSB0aGVzZSBjaGFuZ2VzIHdpdGhcclxuICAgKiBAcGFyYW0gbW9kZWwgUmVxdWlyZWQgaWYgeW91IGhhdmUgZGVmaW5lZCB5b3VyIG1vZGVsLm5vZGVLZXlQcm9wZXJ0eSB0byBiZSBzb21ldGhpbmcgb3RoZXIgdGhhbiAna2V5J1xyXG4gICAqIEByZXR1cm5zIEEgbm9kZSBkYXRhIGFycmF5LCBtZXJnZWQgd2l0aCB0aGUgY2hhbmdlc1xyXG4gICAqL1xyXG4gIHB1YmxpYyBzdGF0aWMgc3luY05vZGVEYXRhKGNoYW5nZXM6IGdvLkluY3JlbWVudGFsRGF0YSwgbm9kZURhdGE6IEFycmF5PGdvLk9iamVjdERhdGE+LCBtb2RlbD86IGdvLk1vZGVsKSB7XHJcbiAgICBpZiAoIWNoYW5nZXMpIHJldHVybiBub2RlRGF0YTtcclxuICAgIGlmICghY2hhbmdlcy5tb2RpZmllZE5vZGVEYXRhICYmICFjaGFuZ2VzLmluc2VydGVkTm9kZUtleXMgJiYgIWNoYW5nZXMucmVtb3ZlZE5vZGVLZXlzKSByZXR1cm4gbm9kZURhdGE7XHJcblxyXG4gICAgLy8gbWFpbnRhaW4gYSBtYXAgb2YgbW9kaWZpZWQgbm9kZXMgZm9yIGZhc3QgbG9va3VwIGR1cmluZyBpbnNlcnRpb25cclxuICAgIGNvbnN0IG1vZGlmaWVkTm9kZXNNYXAgPSBuZXcgZ28uTWFwPGdvLktleSwgZ28uT2JqZWN0RGF0YT4oKTtcclxuXHJcbiAgICAvLyBhY2NvdW50IGZvciBtb2RpZmllZCBub2RlIGRhdGFcclxuICAgIGlmIChjaGFuZ2VzLm1vZGlmaWVkTm9kZURhdGEpIHtcclxuICAgICAgY2hhbmdlcy5tb2RpZmllZE5vZGVEYXRhLmZvckVhY2goKG5kOiBnby5PYmplY3REYXRhKSA9PiB7XHJcbiAgICAgICAgLy8gR2V0IHRoZSB2YWx1ZSBvZiB0aGUgbm9kZSBrZXkgcHJvcGVydHkgY2hlY2tpbmcgd2V0aGVyIGlzIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmdcclxuICAgICAgICBjb25zdCBrZXkgPSBtb2RlbCA/IG1vZGVsLmdldEtleUZvck5vZGVEYXRhKG5kKSA6IG5kWydrZXknXTtcclxuICAgICAgICBtb2RpZmllZE5vZGVzTWFwLnNldChrZXksIG5kKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVEYXRhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBjb25zdCBuZEVudHJ5ID0gbm9kZURhdGFbaV07XHJcbiAgICAgICAgICBjb25zdCBrZXlOZEVudHJ5ID0gbW9kZWwgPyBtb2RlbC5nZXRLZXlGb3JOb2RlRGF0YShuZEVudHJ5KSA6IG5kRW50cnlbJ2tleSddO1xyXG4gICAgICAgICAgaWYgKGtleU5kRW50cnkgPT09IGtleSkge1xyXG4gICAgICAgICAgICBub2RlRGF0YVtpXSA9IG5kO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYWNjb3VudCBmb3IgaW5zZXJ0ZWQgbm9kZSBkYXRhXHJcbiAgICBpZiAoY2hhbmdlcy5pbnNlcnRlZE5vZGVLZXlzKSB7XHJcbiAgICAgIGNoYW5nZXMuaW5zZXJ0ZWROb2RlS2V5cy5mb3JFYWNoKChrZXk6IGdvLktleSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IG5kID0gbW9kaWZpZWROb2Rlc01hcC5nZXQoa2V5KTtcclxuICAgICAgICBpZiAobmQpIHtcclxuICAgICAgICAgIG5vZGVEYXRhLnB1c2gobmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYWNjb3VudCBmb3IgcmVtb3ZlZCBub2RlIGRhdGFcclxuICAgIGlmIChjaGFuZ2VzLnJlbW92ZWROb2RlS2V5cykge1xyXG4gICAgICBub2RlRGF0YSA9IG5vZGVEYXRhLmZpbHRlcigobmQ6IGdvLk9iamVjdERhdGEpID0+IHtcclxuICAgICAgICBjb25zdCBrZXkgPSBtb2RlbCA/IG1vZGVsLmdldEtleUZvck5vZGVEYXRhKG5kKSA6IG5kWydrZXknXTtcclxuICAgICAgICBpZiAoY2hhbmdlcy5yZW1vdmVkTm9kZUtleXMuaW5jbHVkZXMoa2V5KSkge1xyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0gcmV0dXJuIHRydWU7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBub2RlRGF0YTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN5bmMgYSBsaW5rIGRhdGEgYXJyYXkgd2l0aCBhIHNldCBvZiBjaGFuZ2VzXHJcbiAgICogQHBhcmFtIGNoYW5nZXMgVGhlIHNldCBvZiBjaGFuZ2VzIHRvIHRoZSBHb0pTIG1vZGVsXHJcbiAgICogQHBhcmFtIGxpbmtEYXRhIFRoZSBsaW5rIGRhdGEgYXJyYXkgdG8gbWVyZ2UgdGhlc2UgY2hhbmdlcyB3aXRoXHJcbiAgICogQHBhcmFtIG1vZGVsIFJlcXVpcmVkIGlmIHlvdSBoYXZlIGRlZmluZWQgeW91ciBtb2RlbC5saW5rS2V5UHJvcGVydHkgdG8gYmUgc29tZXRoaW5nIG90aGVyIHRoYW4gJ2tleSdcclxuICAgKiBAcmV0dXJucyBBIGxpbmsgZGF0YSBhcnJheSwgbWVyZ2VkIHdpdGggdGhlIGNoYW5nZXNcclxuICAgKi9cclxuICBwdWJsaWMgc3RhdGljIHN5bmNMaW5rRGF0YShjaGFuZ2VzOiBnby5JbmNyZW1lbnRhbERhdGEsIGxpbmtEYXRhOiBBcnJheTxnby5PYmplY3REYXRhPiwgbW9kZWw/OiBnby5HcmFwaExpbmtzTW9kZWwpIHtcclxuICAgIGlmICghY2hhbmdlcykgcmV0dXJuIGxpbmtEYXRhO1xyXG4gICAgaWYgKCFjaGFuZ2VzLm1vZGlmaWVkTGlua0RhdGEgJiYgIWNoYW5nZXMuaW5zZXJ0ZWRMaW5rS2V5cyAmJiAhY2hhbmdlcy5yZW1vdmVkTGlua0tleXMpIHJldHVybiBsaW5rRGF0YTtcclxuXHJcbiAgICAvLyBtYWludGFpbiBhIG1hcCBvZiBtb2RpZmllZCBub2RlcyBmb3IgZmFzdCBsb29rdXAgZHVyaW5nIGluc2VydGlvblxyXG4gICAgY29uc3QgbW9kaWZpZWRMaW5rc01hcCA9IG5ldyBnby5NYXA8Z28uS2V5LCBnby5PYmplY3REYXRhPigpO1xyXG5cclxuICAgIC8vIGFjY291bnQgZm9yIG1vZGlmaWVkIGxpbmsgZGF0YVxyXG4gICAgaWYgKGNoYW5nZXMubW9kaWZpZWRMaW5rRGF0YSkge1xyXG4gICAgICBjaGFuZ2VzLm1vZGlmaWVkTGlua0RhdGEuZm9yRWFjaCgobGQ6IGdvLk9iamVjdERhdGEpID0+IHtcclxuICAgICAgICAvLyBHZXQgdGhlIHZhbHVlIG9mIHRoZSBsaW5rIGtleVxyXG4gICAgICAgIGNvbnN0IGtleSA9IG1vZGVsID8gbW9kZWwuZ2V0S2V5Rm9yTGlua0RhdGEobGQpIDogbGRbJ2tleSddO1xyXG4gICAgICAgIG1vZGlmaWVkTGlua3NNYXAuc2V0KGtleSwgbGQpO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmtEYXRhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBjb25zdCBsZEVudHJ5ID0gbGlua0RhdGFbaV07XHJcbiAgICAgICAgICBjb25zdCBrZXlMZEVudHJ5ID0gbW9kZWwgPyBtb2RlbC5nZXRLZXlGb3JMaW5rRGF0YShsZEVudHJ5KSA6IGxkRW50cnlbJ2tleSddO1xyXG4gICAgICAgICAgaWYgKGtleUxkRW50cnkgPT09IGtleSkge1xyXG4gICAgICAgICAgICBsaW5rRGF0YVtpXSA9IGxkO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYWNjb3VudCBmb3IgaW5zZXJ0ZWQgbGluayBkYXRhXHJcbiAgICBpZiAoY2hhbmdlcy5pbnNlcnRlZExpbmtLZXlzKSB7XHJcbiAgICAgIGNoYW5nZXMuaW5zZXJ0ZWRMaW5rS2V5cy5mb3JFYWNoKChrZXk6IGdvLktleSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IG5kID0gbW9kaWZpZWRMaW5rc01hcC5nZXQoa2V5KTtcclxuICAgICAgICBpZiAobmQpIHtcclxuICAgICAgICAgIGxpbmtEYXRhLnB1c2gobmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYWNjb3VudCBmb3IgcmVtb3ZlZCBsaW5rIGRhdGFcclxuICAgIGlmIChjaGFuZ2VzLnJlbW92ZWRMaW5rS2V5cykge1xyXG4gICAgICBsaW5rRGF0YSA9IGxpbmtEYXRhLmZpbHRlcigobGQ6IGdvLk9iamVjdERhdGEpID0+IHtcclxuICAgICAgICBjb25zdCBrZXkgPSBtb2RlbCA/IG1vZGVsLmdldEtleUZvckxpbmtEYXRhKGxkKSA6IGxkWydrZXknXTtcclxuICAgICAgICBpZiAoY2hhbmdlcy5yZW1vdmVkTGlua0tleXMuaW5jbHVkZXMoa2V5KSkge1xyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0gcmV0dXJuIHRydWU7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBsaW5rRGF0YTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN5bmMgbW9kZWxEYXRhIHdpdGggYSBzZXQgb2YgY2hhbmdlc1xyXG4gICAqIEBwYXJhbSBjaGFuZ2VzIFRoZSBzZXQgb2YgY2hhbmdlcyB0byB0aGUgR29KUyBtb2RlbFxyXG4gICAqIEBwYXJhbSBtb2RlbERhdGEgVGhlIG1vZGVsRGF0YSB0byBtZXJnZSB0aGVzZSBjaGFuZ2VzIHdpdGhcclxuICAgKiBAcmV0dXJucyBBIG1vZGVsRGF0YSBvYmplY3QsIG1lcmdlZCB3aXRoIHRoZSBjaGFuZ2VzXHJcbiAgICovXHJcbiAgcHVibGljIHN0YXRpYyBzeW5jTW9kZWxEYXRhKGNoYW5nZXM6IGdvLkluY3JlbWVudGFsRGF0YSwgbW9kZWxEYXRhOiBnby5PYmplY3REYXRhKSB7XHJcbiAgICBpZiAoIWNoYW5nZXMpIHJldHVybiBtb2RlbERhdGE7XHJcbiAgICBpZiAoIWNoYW5nZXMubW9kZWxEYXRhKSByZXR1cm4gbW9kZWxEYXRhO1xyXG4gICAgaWYgKGNoYW5nZXMubW9kZWxEYXRhKSB7XHJcbiAgICAgIHJldHVybiBjaGFuZ2VzLm1vZGVsRGF0YTtcclxuICAgIH1cclxuICB9XHJcblxyXG5cclxufVxyXG4iXX0=