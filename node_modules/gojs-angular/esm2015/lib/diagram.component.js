/**
 * @fileoverview added by tsickle
 * Generated from: lib/diagram.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, ElementRef, EventEmitter, Input, KeyValueDiffers, NgZone, Output, ViewChild } from '@angular/core';
import * as go from 'gojs';
export class DiagramComponent {
    /**
     * @param {?} _kvdiffers
     * @param {?} zone
     */
    constructor(_kvdiffers, zone) {
        this._kvdiffers = _kvdiffers;
        this.zone = zone;
        // Link data for diagram
        this.linkDataArray = null; // optional
        // optional
        // Model data for diagram
        this.modelData = null; // optional
        // model changed listener function for diagram
        this.modelChangedListener = null;
        this.skipsDiagramUpdate = false;
        // event emitter -- fires when diagram model changes. Capture this emitted event in parent component
        this.modelChange = new EventEmitter();
        this.diagram = null;
        // differs used to check if there have been changed to the array @Inputs
        // without them, changes to the input arrays won't register in ngOnChanges,
        // since the array reference itself may be the same
        this._ndaDiffer = this._kvdiffers.find([]).create();
        this._ldaDiffer = this._kvdiffers.find([]).create();
        this._mdaDiffer = this._kvdiffers.find([]).create();
    }
    /**
     * Initializes diagram / model after view init
     * @return {?}
     */
    ngAfterViewInit() {
        this.diagram = this.initDiagram();
        // This bit of code makes sure the mousemove event listeners on the canvas are run outside NgZone
        // This makes it so change detection isn't triggered every time the mouse is moved inside the canvas, greatly improving performance
        // If some state-altering behavior must happen on a mousemove event inside the diagram,
        // you will have to using zone.run() to make sure that event triggers angular change detection
        this.diagram.addEventListener = (/**
         * @param {?} DOMElement
         * @param {?} name
         * @param {?} listener
         * @param {?} capture
         * @return {?}
         */
        (DOMElement, name, listener, capture) => {
            /** @type {?} */
            const superAddEventListener = go.Diagram.prototype.addEventListener;
            if (name === 'mousemove') {
                this.zone.runOutsideAngular((/**
                 * @return {?}
                 */
                () => superAddEventListener.call(this, DOMElement, name, listener, capture)));
            }
            else {
                this.zone.run((/**
                 * @return {?}
                 */
                () => {
                    superAddEventListener.call(this, DOMElement, name, listener, capture);
                }));
            }
        });
        // assign the Diagram's div, which (among many other things) will attach a bunch of listeners to the canvas,
        // using the overridden addEventListener function above
        /** @type {?} */
        const divRef = this.diagramDiv.nativeElement;
        if (divRef === null)
            return;
        this.diagram.div = divRef;
        // initialize the Diagram's model
        this.diagram.delayInitialization((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const model = this.diagram.model;
            model.commit((/**
             * @param {?} m
             * @return {?}
             */
            (m) => {
                m.mergeNodeDataArray(m.cloneDeep(this.nodeDataArray));
                if (this.linkDataArray && m instanceof go.GraphLinksModel) {
                    m.mergeLinkDataArray(m.cloneDeep(this.linkDataArray));
                }
                if (this.modelData) {
                    m.assignAllDataProperties(m.modelData, this.modelData);
                }
                this.diagram.layoutDiagram(true);
            }), null);
        }));
        // initializer listener
        this.modelChangedListener = (/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            if (e.isTransactionFinished && this.diagram && this.diagram.model && !this.diagram.model.isReadOnly) {
                // this must be done within a NgZone.run block, so changes are detected in the parent component
                this.zone.run((/**
                 * @return {?}
                 */
                () => {
                    /** @type {?} */
                    const dataChanges = (/** @type {?} */ (e.model)).toIncrementalData(e);
                    this.modelChange.emit(dataChanges);
                }));
            }
        });
        this.diagram.addModelChangedListener(this.modelChangedListener);
    } // end ngAfterViewInit
    // end ngAfterViewInit
    /**
     * Merges changes from app data into GoJS model data,
     * making sure only actual changes (and not falsely flagged no-ops on array / obj data props) are logged
     * @param {?} component an instance of DiagramComponent or PaletteComponent
     * @param {?} kvchanges The kvchanges object produced by either a node or link Angular differ object
     * @param {?} str "n" for node data changes, "l" for link data changes
     *
     * @return {?}
     */
    static mergeChanges(component, kvchanges, str) {
        // helper function
        /**
         * @param {?} obj1
         * @param {?} obj2
         * @return {?}
         */
        function compareObjs(obj1, obj2) {
            if (!obj1 || !obj2)
                return false;
            // Loop through properties in object 1
            for (const p in obj1) {
                // Check property exists on both objects
                if (obj1.hasOwnProperty(p) !== obj2.hasOwnProperty(p))
                    return false;
                switch (typeof (obj1[p])) {
                    // Deep compare objects
                    case 'object':
                        if (!compareObjs(obj1[p], obj2[p]))
                            return false;
                        break;
                    // Compare values
                    default:
                        if (obj1[p] !== obj2[p])
                            return false;
                }
            }
            // Check object 2 for any extra properties
            for (const p in obj2) {
                if (typeof (obj1[p]) === 'undefined')
                    return false;
            }
            return true;
        }
        /** @type {?} */
        var dia = component instanceof DiagramComponent ? component.diagram : component.palette;
        if (!dia || !dia.model)
            return;
        if (kvchanges) {
            // handle added nodes / links
            kvchanges.forEachAddedItem((/**
             * @param {?} r
             * @return {?}
             */
            (r) => {
                switch (str) {
                    case "n": {
                        dia.model.addNodeData(r.currentValue);
                        break;
                    }
                    case "l": {
                        /** @type {?} */
                        var m = (/** @type {?} */ (dia.model));
                        m.addLinkData(r.currentValue);
                        break;
                    }
                }
            }));
            // handle removed nodes / links
            kvchanges.forEachRemovedItem((/**
             * @param {?} r
             * @return {?}
             */
            (r) => {
                switch (str) {
                    case "n": {
                        /** @type {?} */
                        let m = dia.model;
                        /** @type {?} */
                        let keyPropName = m.nodeKeyProperty.toString();
                        /** @type {?} */
                        var node = dia.findNodeForKey(r.previousValue[keyPropName]);
                        if (node) {
                            dia.remove(node);
                        }
                        break;
                    }
                    case "l": {
                        /** @type {?} */
                        let m = (/** @type {?} */ (dia.model));
                        /** @type {?} */
                        var keyPropName = m.linkKeyProperty.toString();
                        /** @type {?} */
                        var link = dia.findLinkForKey(r.previousValue[keyPropName]);
                        if (link) {
                            dia.remove(link);
                        }
                        break;
                    }
                }
            }));
            // handle changed data for nodes / links
            kvchanges.forEachChangedItem((/**
             * @param {?} r
             * @return {?}
             */
            (r) => {
                // ensure "changes" to array / object / enumerable data properties are legit
                /** @type {?} */
                const sameVals = compareObjs(r.currentValue, r.previousValue);
                // update proper data object for node or link
                if (!sameVals) {
                    switch (str) {
                        case "n": {
                            /** @type {?} */
                            let m = dia.model;
                            /** @type {?} */
                            let keyPropName = m.nodeKeyProperty.toString();
                            /** @type {?} */
                            var node = dia.findNodeForKey(r.previousValue[keyPropName]);
                            if (node) {
                                // if the entry was replaced with null or undefined, just remove the entry altogther
                                // this is still pretty bad practice -- instead, users should remove entries in their node / link / model data, not set them to null
                                if (!r.currentValue) {
                                    dia.remove(node);
                                }
                                else {
                                    dia.model.assignAllDataProperties(node.data, r.currentValue);
                                }
                            }
                            break;
                        }
                        case "l": {
                            /** @type {?} */
                            let m = (/** @type {?} */ (dia.model));
                            /** @type {?} */
                            var keyPropName = m.linkKeyProperty.toString();
                            /** @type {?} */
                            var link = dia.findLinkForKey(r.previousValue[keyPropName]);
                            if (link) {
                                // if the entry was replaced with null or undefined, just remove the entry altogther
                                // this is still pretty bad practice -- instead, users should remove entries in their node / link / model data, not set them to null
                                if (!r.currentValue) {
                                    dia.remove(link);
                                }
                                else {
                                    dia.model.assignAllDataProperties(link.data, r.currentValue);
                                }
                            }
                            break;
                        }
                    }
                }
            }));
        }
    }
    /**
     * Always be checking if array Input data has changed (node and link data arrays)
     * @return {?}
     */
    ngDoCheck() {
        if (!this.diagram)
            return;
        if (!this.diagram.model)
            return;
        // these need to be run each check, even if no merging happens
        // otherwise, they will detect all diffs that happened since last time skipsDiagram was false,
        // such as remove ops that happened in GoJS when skipsDiagram = true, 
        // and then realllllly bad stuff happens (deleting random nodes, updating the wrong Parts)
        // Angular differs are a lot of fun
        /** @type {?} */
        var nodeDiffs = this._ndaDiffer.diff(this.nodeDataArray);
        /** @type {?} */
        var linkDiffs = this._ldaDiffer.diff(this.linkDataArray);
        /** @type {?} */
        var modelDiffs = this._mdaDiffer.diff(this.modelData);
        if (!nodeDiffs && !linkDiffs && !modelDiffs)
            return;
        if (this.skipsDiagramUpdate)
            return;
        // don't need model change listener while performing known data updates
        if (this.modelChangedListener !== null)
            this.diagram.model.removeChangedListener(this.modelChangedListener);
        this.diagram.model.startTransaction('update data');
        // update modelData first, in case bindings on nodes / links depend on model data
        this.diagram.model.assignAllDataProperties(this.diagram.model.modelData, this.modelData);
        // merge node / link data
        DiagramComponent.mergeChanges(this, nodeDiffs, "n");
        DiagramComponent.mergeChanges(this, linkDiffs, "l");
        this.diagram.model.commitTransaction('update data');
        // reset the model change listener
        if (this.modelChangedListener !== null)
            this.diagram.model.addChangedListener(this.modelChangedListener);
    } // end ngDoCheck
    // end ngDoCheck
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.diagram.div = null; // removes event listeners
    }
}
DiagramComponent.decorators = [
    { type: Component, args: [{
                selector: 'gojs-diagram',
                template: '<div #ngDiagram [className]=divClassName></div>'
            }] }
];
/** @nocollapse */
DiagramComponent.ctorParameters = () => [
    { type: KeyValueDiffers },
    { type: NgZone }
];
DiagramComponent.propDecorators = {
    initDiagram: [{ type: Input }],
    nodeDataArray: [{ type: Input }],
    linkDataArray: [{ type: Input }],
    modelData: [{ type: Input }],
    divClassName: [{ type: Input }],
    skipsDiagramUpdate: [{ type: Input }],
    modelChange: [{ type: Output }],
    diagramDiv: [{ type: ViewChild, args: ['ngDiagram', { static: true },] }]
};
if (false) {
    /**
     * Diagram initialization function. Returns a go.Diagram.
     * Do not initialize model data in this function.
     * @type {?}
     */
    DiagramComponent.prototype.initDiagram;
    /** @type {?} */
    DiagramComponent.prototype.nodeDataArray;
    /** @type {?} */
    DiagramComponent.prototype.linkDataArray;
    /** @type {?} */
    DiagramComponent.prototype.modelData;
    /** @type {?} */
    DiagramComponent.prototype.divClassName;
    /** @type {?} */
    DiagramComponent.prototype.modelChangedListener;
    /** @type {?} */
    DiagramComponent.prototype.skipsDiagramUpdate;
    /** @type {?} */
    DiagramComponent.prototype.modelChange;
    /** @type {?} */
    DiagramComponent.prototype.diagramDiv;
    /** @type {?} */
    DiagramComponent.prototype.diagram;
    /**
     * @type {?}
     * @private
     */
    DiagramComponent.prototype._ndaDiffer;
    /**
     * @type {?}
     * @private
     */
    DiagramComponent.prototype._ldaDiffer;
    /**
     * @type {?}
     * @private
     */
    DiagramComponent.prototype._mdaDiffer;
    /**
     * @type {?}
     * @private
     */
    DiagramComponent.prototype._kvdiffers;
    /** @type {?} */
    DiagramComponent.prototype.zone;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGlhZ3JhbS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wcm9qZWN0cy9nb2pzLWFuZ3VsYXIvc3JjL2xpYi9kaWFncmFtLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsVUFBVSxFQUFFLFlBQVksRUFBRSxLQUFLLEVBQWtCLGVBQWUsRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLFNBQVMsRUFBd0IsTUFBTSxlQUFlLENBQUM7QUFDN0osT0FBTyxLQUFLLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFNM0IsTUFBTSxPQUFPLGdCQUFnQjs7Ozs7SUFxQzNCLFlBQW9CLFVBQTJCLEVBQVMsSUFBWTtRQUFoRCxlQUFVLEdBQVYsVUFBVSxDQUFpQjtRQUFTLFNBQUksR0FBSixJQUFJLENBQVE7O1FBekJwRCxrQkFBYSxHQUF5QixJQUFJLENBQUMsQ0FBQyxXQUFXOzs7UUFHdkQsY0FBUyxHQUFrQixJQUFJLENBQUMsQ0FBQyxXQUFXOztRQU1yRCx5QkFBb0IsR0FBd0MsSUFBSSxDQUFDO1FBRXhELHVCQUFrQixHQUFZLEtBQUssQ0FBQzs7UUFHbkMsZ0JBQVcsR0FBcUMsSUFBSSxZQUFZLEVBQXNCLENBQUM7UUFHakcsWUFBTyxHQUFlLElBQUksQ0FBQztRQVNoQyx3RUFBd0U7UUFDeEUsMkVBQTJFO1FBQzNFLG1EQUFtRDtRQUNuRCxJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQ3BELElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUM7UUFFcEQsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMs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MEJBR0wsTUFBTTt5QkFFTixTQUFTLFNBQUMsV0FBVyxFQUFFLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRTs7Ozs7Ozs7SUF0QnhDLHVDQUE4Qzs7SUFHOUMseUNBQW9EOztJQUdwRCx5Q0FBMkQ7O0lBRzNELHFDQUFnRDs7SUFHaEQsd0NBQXFDOztJQUdyQyxnREFBd0U7O0lBRXhFLDhDQUFvRDs7SUFHcEQsdUNBQXdHOztJQUV4RyxzQ0FBd0U7O0lBQ3hFLG1DQUFrQzs7Ozs7SUFHbEMsc0NBQWdEOzs7OztJQUNoRCxzQ0FBZ0Q7Ozs7O0lBRWhELHNDQUFnRDs7Ozs7SUFFcEMsc0NBQW1DOztJQUFFLGdDQUFtQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgS2V5VmFsdWVEaWZmZXIsIEtleVZhbHVlRGlmZmVycywgTmdab25lLCBPdXRwdXQsIFZpZXdDaGlsZCwgS2V5VmFsdWVDaGFuZ2VSZWNvcmQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0ICogYXMgZ28gZnJvbSAnZ29qcyc7XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICBzZWxlY3RvcjogJ2dvanMtZGlhZ3JhbScsXHJcbiAgdGVtcGxhdGU6ICc8ZGl2ICNuZ0RpYWdyYW0gW2NsYXNzTmFtZV09ZGl2Q2xhc3NOYW1lPjwvZGl2PidcclxufSlcclxuZXhwb3J0IGNsYXNzIERpYWdyYW1Db21wb25lbnQge1xyXG5cclxuICAvKipcclxuICAgKiBEaWFncmFtIGluaXRpYWxpemF0aW9uIGZ1bmN0aW9uLiBSZXR1cm5zIGEgZ28uRGlhZ3JhbS5cclxuICAgKiBEbyBub3QgaW5pdGlhbGl6ZSBtb2RlbCBkYXRhIGluIHRoaXMgZnVuY3Rpb24uXHJcbiAgICovXHJcbiAgQElucHV0KCkgcHVibGljIGluaXREaWFncmFtOiAoKSA9PiBnby5EaWFncmFtO1xyXG5cclxuICAvLyBOb2RlIGRhdGEgZm9yIGRpYWdyYW1cclxuICBASW5wdXQoKSBwdWJsaWMgbm9kZURhdGFBcnJheTogQXJyYXk8Z28uT2JqZWN0RGF0YT47XHJcblxyXG4gIC8vIExpbmsgZGF0YSBmb3IgZGlhZ3JhbVxyXG4gIEBJbnB1dCgpIHB1YmxpYyBsaW5rRGF0YUFycmF5OiBBcnJheTxnby5PYmplY3REYXRhPiA9IG51bGw7IC8vIG9wdGlvbmFsXHJcblxyXG4gIC8vIE1vZGVsIGRhdGEgZm9yIGRpYWdyYW1cclxuICBASW5wdXQoKSBwdWJsaWMgbW9kZWxEYXRhOiBnby5PYmplY3REYXRhID0gbnVsbDsgLy8gb3B0aW9uYWxcclxuXHJcbiAgLy8gRGlhZ3JhbSBkaXYgY2xhc3MgbmFtZS4gVXNlIHRoaXMgbmFtZSB0byBzdHlsZSB5b3VyIGRpYWdyYW0gaW4gQ1NTXHJcbiAgQElucHV0KCkgcHVibGljIGRpdkNsYXNzTmFtZTogc3RyaW5nO1xyXG5cclxuICAvLyBtb2RlbCBjaGFuZ2VkIGxpc3RlbmVyIGZ1bmN0aW9uIGZvciBkaWFncmFtXHJcbiAgcHVibGljIG1vZGVsQ2hhbmdlZExpc3RlbmVyOiAoZTogZ28uQ2hhbmdlZEV2ZW50KSA9PiB2b2lkIHwgbnVsbCA9IG51bGw7XHJcblxyXG4gIEBJbnB1dCgpIHB1YmxpYyBza2lwc0RpYWdyYW1VcGRhdGU6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcbiAgLy8gZXZlbnQgZW1pdHRlciAtLSBmaXJlcyB3aGVuIGRpYWdyYW0gbW9kZWwgY2hhbmdlcy4gQ2FwdHVyZSB0aGlzIGVtaXR0ZWQgZXZlbnQgaW4gcGFyZW50IGNvbXBvbmVudFxyXG4gIEBPdXRwdXQoKSBwdWJsaWMgbW9kZWxDaGFuZ2U6IEV2ZW50RW1pdHRlcjxnby5JbmNyZW1lbnRhbERhdGE+ID0gbmV3IEV2ZW50RW1pdHRlcjxnby5JbmNyZW1lbnRhbERhdGE+KCk7XHJcblxyXG4gIEBWaWV3Q2hpbGQoJ25nRGlhZ3JhbScsIHsgc3RhdGljOiB0cnVlIH0pIHB1YmxpYyBkaWFncmFtRGl2OiBFbGVtZW50UmVmO1xyXG4gIHB1YmxpYyBkaWFncmFtOiBnby5EaWFncmFtID0gbnVsbDtcclxuXHJcbiAgLy8gZGlmZmVycyBmb3IgYXJyYXkgaW5wdXRzIChub2RlIC8gbGluayBkYXRhIGFycmF5cylcclxuICBwcml2YXRlIF9uZGFEaWZmZXI6IEtleVZhbHVlRGlmZmVyPHN0cmluZywgYW55PjtcclxuICBwcml2YXRlIF9sZGFEaWZmZXI6IEtleVZhbHVlRGlmZmVyPHN0cmluZywgYW55PjtcclxuXHJcbiAgcHJpdmF0ZSBfbWRhRGlmZmVyOiBLZXlWYWx1ZURpZmZlcjxzdHJpbmcsIGFueT47XHJcblxyXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX2t2ZGlmZmVyczogS2V5VmFsdWVEaWZmZXJzLCBwdWJsaWMgem9uZTogTmdab25lKSB7XHJcbiAgICAvLyBkaWZmZXJzIHVzZWQgdG8gY2hlY2sgaWYgdGhlcmUgaGF2ZSBiZWVuIGNoYW5nZWQgdG8gdGhlIGFycmF5IEBJbnB1dHNcclxuICAgIC8vIHdpdGhvdXQgdGhlbSwgY2hhbmdlcyB0byB0aGUgaW5wdXQgYXJyYXlzIHdvbid0IHJlZ2lzdGVyIGluIG5nT25DaGFuZ2VzLFxyXG4gICAgLy8gc2luY2UgdGhlIGFycmF5IHJlZmVyZW5jZSBpdHNlbGYgbWF5IGJlIHRoZSBzYW1lXHJcbiAgICB0aGlzLl9uZGFEaWZmZXIgPSB0aGlzLl9rdmRpZmZlcnMuZmluZChbXSkuY3JlYXRlKCk7XHJcbiAgICB0aGlzLl9sZGFEaWZmZXIgPSB0aGlzLl9rdmRpZmZlcnMuZmluZChbXSkuY3JlYXRlKCk7XHJcblxyXG4gICAgdGhpcy5fbWRhRGlmZmVyID0gdGhpcy5fa3ZkaWZmZXJzLmZpbmQoW10pLmNyZWF0ZSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW5pdGlhbGl6ZXMgZGlhZ3JhbSAvIG1vZGVsIGFmdGVyIHZpZXcgaW5pdFxyXG4gICAqL1xyXG4gIHB1YmxpYyBuZ0FmdGVyVmlld0luaXQoKSB7XHJcbiAgICB0aGlzLmRpYWdyYW0gPSB0aGlzLmluaXREaWFncmFtKCk7XHJcblxyXG4gICAgLy8gVGhpcyBiaXQgb2YgY29kZSBtYWtlcyBzdXJlIHRoZSBtb3VzZW1vdmUgZXZlbnQgbGlzdGVuZXJzIG9uIHRoZSBjYW52YXMgYXJlIHJ1biBvdXRzaWRlIE5nWm9uZVxyXG4gICAgLy8gVGhpcyBtYWtlcyBpdCBzbyBjaGFuZ2UgZGV0ZWN0aW9uIGlzbid0IHRyaWdnZXJlZCBldmVyeSB0aW1lIHRoZSBtb3VzZSBpcyBtb3ZlZCBpbnNpZGUgdGhlIGNhbnZhcywgZ3JlYXRseSBpbXByb3ZpbmcgcGVyZm9ybWFuY2VcclxuICAgIC8vIElmIHNvbWUgc3RhdGUtYWx0ZXJpbmcgYmVoYXZpb3IgbXVzdCBoYXBwZW4gb24gYSBtb3VzZW1vdmUgZXZlbnQgaW5zaWRlIHRoZSBkaWFncmFtLFxyXG4gICAgLy8geW91IHdpbGwgaGF2ZSB0byB1c2luZyB6b25lLnJ1bigpIHRvIG1ha2Ugc3VyZSB0aGF0IGV2ZW50IHRyaWdnZXJzIGFuZ3VsYXIgY2hhbmdlIGRldGVjdGlvblxyXG4gICAgdGhpcy5kaWFncmFtLmFkZEV2ZW50TGlzdGVuZXIgPSAoRE9NRWxlbWVudDogRWxlbWVudCB8IFdpbmRvdyB8IERvY3VtZW50LCBuYW1lOiBzdHJpbmcsIGxpc3RlbmVyOiBhbnksIGNhcHR1cmU6IGJvb2xlYW4pID0+IHtcclxuICAgICAgY29uc3Qgc3VwZXJBZGRFdmVudExpc3RlbmVyID0gZ28uRGlhZ3JhbS5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcjtcclxuICAgICAgaWYgKG5hbWUgPT09ICdtb3VzZW1vdmUnKSB7XHJcbiAgICAgICAgdGhpcy56b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHN1cGVyQWRkRXZlbnRMaXN0ZW5lci5jYWxsKHRoaXMsIERPTUVsZW1lbnQsIG5hbWUsIGxpc3RlbmVyLCBjYXB0dXJlKSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy56b25lLnJ1bigoKSA9PiB7XHJcbiAgICAgICAgICBzdXBlckFkZEV2ZW50TGlzdGVuZXIuY2FsbCh0aGlzLCBET01FbGVtZW50LCBuYW1lLCBsaXN0ZW5lciwgY2FwdHVyZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy8gYXNzaWduIHRoZSBEaWFncmFtJ3MgZGl2LCB3aGljaCAoYW1vbmcgbWFueSBvdGhlciB0aGluZ3MpIHdpbGwgYXR0YWNoIGEgYnVuY2ggb2YgbGlzdGVuZXJzIHRvIHRoZSBjYW52YXMsXHJcbiAgICAvLyB1c2luZyB0aGUgb3ZlcnJpZGRlbiBhZGRFdmVudExpc3RlbmVyIGZ1bmN0aW9uIGFib3ZlXHJcbiAgICBjb25zdCBkaXZSZWYgPSB0aGlzLmRpYWdyYW1EaXYubmF0aXZlRWxlbWVudDtcclxuICAgIGlmIChkaXZSZWYgPT09IG51bGwpIHJldHVybjtcclxuICAgIHRoaXMuZGlhZ3JhbS5kaXYgPSBkaXZSZWY7XHJcblxyXG4gICAgLy8gaW5pdGlhbGl6ZSB0aGUgRGlhZ3JhbSdzIG1vZGVsXHJcbiAgICB0aGlzLmRpYWdyYW0uZGVsYXlJbml0aWFsaXphdGlvbigoKSA9PiB7XHJcbiAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5kaWFncmFtLm1vZGVsO1xyXG4gICAgICBtb2RlbC5jb21taXQoKG06IGdvLk1vZGVsKSA9PiB7XHJcbiAgICAgICAgbS5tZXJnZU5vZGVEYXRhQXJyYXkobS5jbG9uZURlZXAodGhpcy5ub2RlRGF0YUFycmF5KSk7XHJcbiAgICAgICAgaWYgKHRoaXMubGlua0RhdGFBcnJheSAmJiBtIGluc3RhbmNlb2YgZ28uR3JhcGhMaW5rc01vZGVsKSB7XHJcbiAgICAgICAgICBtLm1lcmdlTGlua0RhdGFBcnJheShtLmNsb25lRGVlcCh0aGlzLmxpbmtEYXRhQXJyYXkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMubW9kZWxEYXRhKSB7XHJcbiAgICAgICAgICBtLmFzc2lnbkFsbERhdGFQcm9wZXJ0aWVzKG0ubW9kZWxEYXRhLCB0aGlzLm1vZGVsRGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZGlhZ3JhbS5sYXlvdXREaWFncmFtKHRydWUpO1xyXG4gICAgICB9LCBudWxsKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIGluaXRpYWxpemVyIGxpc3RlbmVyXHJcbiAgICB0aGlzLm1vZGVsQ2hhbmdlZExpc3RlbmVyID0gKGU6IGdvLkNoYW5nZWRFdmVudCkgPT4ge1xyXG4gICAgICBpZiAoZS5pc1RyYW5zYWN0aW9uRmluaXNoZWQgJiYgdGhpcy5kaWFncmFtICYmIHRoaXMuZGlhZ3JhbS5tb2RlbCAmJiAhdGhpcy5kaWFncmFtLm1vZGVsLmlzUmVhZE9ubHkpIHtcclxuICAgICAgICAvLyB0aGlzIG11c3QgYmUgZG9uZSB3aXRoaW4gYSBOZ1pvbmUucnVuIGJsb2NrLCBzbyBjaGFuZ2VzIGFyZSBkZXRlY3RlZCBpbiB0aGUgcGFyZW50IGNvbXBvbmVudFxyXG4gICAgICAgIHRoaXMuem9uZS5ydW4oKCkgPT4ge1xyXG4gICAgICAgICAgY29uc3QgZGF0YUNoYW5nZXMgPSBlLm1vZGVsIS50b0luY3JlbWVudGFsRGF0YShlKTtcclxuICAgICAgICAgIHRoaXMubW9kZWxDaGFuZ2UuZW1pdChkYXRhQ2hhbmdlcyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICB0aGlzLmRpYWdyYW0uYWRkTW9kZWxDaGFuZ2VkTGlzdGVuZXIodGhpcy5tb2RlbENoYW5nZWRMaXN0ZW5lcik7XHJcblxyXG5cclxuICB9IC8vIGVuZCBuZ0FmdGVyVmlld0luaXRcclxuXHJcbiAgLyoqXHJcbiAgICogTWVyZ2VzIGNoYW5nZXMgZnJvbSBhcHAgZGF0YSBpbnRvIEdvSlMgbW9kZWwgZGF0YSwgXHJcbiAgICogbWFraW5nIHN1cmUgb25seSBhY3R1YWwgY2hhbmdlcyAoYW5kIG5vdCBmYWxzZWx5IGZsYWdnZWQgbm8tb3BzIG9uIGFycmF5IC8gb2JqIGRhdGEgcHJvcHMpIGFyZSBsb2dnZWRcclxuICAgKiBAcGFyYW0gY29tcG9uZW50IGFuIGluc3RhbmNlIG9mIERpYWdyYW1Db21wb25lbnQgb3IgUGFsZXR0ZUNvbXBvbmVudFxyXG4gICAqIEBwYXJhbSBrdmNoYW5nZXMgVGhlIGt2Y2hhbmdlcyBvYmplY3QgcHJvZHVjZWQgYnkgZWl0aGVyIGEgbm9kZSBvciBsaW5rIEFuZ3VsYXIgZGlmZmVyIG9iamVjdFxyXG4gICAqIEBwYXJhbSBzdHIgXCJuXCIgZm9yIG5vZGUgZGF0YSBjaGFuZ2VzLCBcImxcIiBmb3IgbGluayBkYXRhIGNoYW5nZXNcclxuICAgKiAgKi8gXHJcbiAgcHVibGljIHN0YXRpYyBtZXJnZUNoYW5nZXMoY29tcG9uZW50LCBrdmNoYW5nZXMsIHN0cik6IGJvb2xlYW4ge1xyXG5cclxuICAgIC8vIGhlbHBlciBmdW5jdGlvblxyXG4gICAgZnVuY3Rpb24gY29tcGFyZU9ianMob2JqMSwgb2JqMikge1xyXG5cclxuICAgICAgaWYgKCFvYmoxIHx8ICFvYmoyKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAvLyBMb29wIHRocm91Z2ggcHJvcGVydGllcyBpbiBvYmplY3QgMVxyXG4gICAgICBmb3IgKGNvbnN0IHAgaW4gb2JqMSkge1xyXG4gICAgICAgIC8vIENoZWNrIHByb3BlcnR5IGV4aXN0cyBvbiBib3RoIG9iamVjdHNcclxuICAgICAgICBpZiAob2JqMS5oYXNPd25Qcm9wZXJ0eShwKSAhPT0gb2JqMi5oYXNPd25Qcm9wZXJ0eShwKSkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICBzd2l0Y2ggKHR5cGVvZiAob2JqMVtwXSkpIHtcclxuICAgICAgICAgIC8vIERlZXAgY29tcGFyZSBvYmplY3RzXHJcbiAgICAgICAgICBjYXNlICdvYmplY3QnOlxyXG4gICAgICAgICAgICBpZiAoIWNvbXBhcmVPYmpzKG9iajFbcF0sIG9iajJbcF0pKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgLy8gQ29tcGFyZSB2YWx1ZXNcclxuICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIGlmIChvYmoxW3BdICE9PSBvYmoyW3BdKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDaGVjayBvYmplY3QgMiBmb3IgYW55IGV4dHJhIHByb3BlcnRpZXNcclxuICAgICAgZm9yIChjb25zdCBwIGluIG9iajIpIHtcclxuICAgICAgICBpZiAodHlwZW9mIChvYmoxW3BdKSA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZGlhID0gY29tcG9uZW50IGluc3RhbmNlb2YgRGlhZ3JhbUNvbXBvbmVudCA/IGNvbXBvbmVudC5kaWFncmFtIDogY29tcG9uZW50LnBhbGV0dGU7XHJcblxyXG4gICAgaWYgKCFkaWEgfHwgIWRpYS5tb2RlbCkgcmV0dXJuO1xyXG5cclxuICAgIGlmIChrdmNoYW5nZXMpIHtcclxuXHJcbiAgICAgIC8vIGhhbmRsZSBhZGRlZCBub2RlcyAvIGxpbmtzXHJcbiAgICAgIGt2Y2hhbmdlcy5mb3JFYWNoQWRkZWRJdGVtKChyOiBLZXlWYWx1ZUNoYW5nZVJlY29yZDxzdHJpbmcsIGFueT4pID0+IHtcclxuICAgICAgICBzd2l0Y2ggKHN0cikge1xyXG4gICAgICAgICAgY2FzZSBcIm5cIjoge1xyXG4gICAgICAgICAgICBkaWEubW9kZWwuYWRkTm9kZURhdGEoci5jdXJyZW50VmFsdWUpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGNhc2UgXCJsXCI6IHtcclxuICAgICAgICAgICAgdmFyIG0gPSA8Z28uR3JhcGhMaW5rc01vZGVsPmRpYS5tb2RlbDtcclxuICAgICAgICAgICAgbS5hZGRMaW5rRGF0YShyLmN1cnJlbnRWYWx1ZSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBoYW5kbGUgcmVtb3ZlZCBub2RlcyAvIGxpbmtzXHJcbiAgICAgIGt2Y2hhbmdlcy5mb3JFYWNoUmVtb3ZlZEl0ZW0oKHI6IEtleVZhbHVlQ2hhbmdlUmVjb3JkPHN0cmluZywgYW55PikgPT4ge1xyXG4gICAgICAgIHN3aXRjaCAoc3RyKSB7XHJcbiAgICAgICAgICBjYXNlIFwiblwiOiB7XHJcbiAgICAgICAgICAgIGxldCBtID0gZGlhLm1vZGVsO1xyXG4gICAgICAgICAgICBsZXQga2V5UHJvcE5hbWUgPSBtLm5vZGVLZXlQcm9wZXJ0eS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICB2YXIgbm9kZSA9IGRpYS5maW5kTm9kZUZvcktleShyLnByZXZpb3VzVmFsdWVba2V5UHJvcE5hbWVdKTtcclxuICAgICAgICAgICAgaWYgKG5vZGUpIHtcclxuICAgICAgICAgICAgICBkaWEucmVtb3ZlKG5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgY2FzZSBcImxcIjoge1xyXG4gICAgICAgICAgICBsZXQgbSA9IDxnby5HcmFwaExpbmtzTW9kZWw+ZGlhLm1vZGVsO1xyXG4gICAgICAgICAgICB2YXIga2V5UHJvcE5hbWUgPSBtLmxpbmtLZXlQcm9wZXJ0eS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICB2YXIgbGluayA9IGRpYS5maW5kTGlua0ZvcktleShyLnByZXZpb3VzVmFsdWVba2V5UHJvcE5hbWVdKTtcclxuICAgICAgICAgICAgaWYgKGxpbmspIHtcclxuICAgICAgICAgICAgICBkaWEucmVtb3ZlKGxpbmspO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBoYW5kbGUgY2hhbmdlZCBkYXRhIGZvciBub2RlcyAvIGxpbmtzXHJcbiAgICAgIGt2Y2hhbmdlcy5mb3JFYWNoQ2hhbmdlZEl0ZW0oKHI6IEtleVZhbHVlQ2hhbmdlUmVjb3JkPHN0cmluZywgYW55PikgPT4ge1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIGVuc3VyZSBcImNoYW5nZXNcIiB0byBhcnJheSAvIG9iamVjdCAvIGVudW1lcmFibGUgZGF0YSBwcm9wZXJ0aWVzIGFyZSBsZWdpdFxyXG4gICAgICAgIGNvbnN0IHNhbWVWYWxzID0gY29tcGFyZU9ianMoci5jdXJyZW50VmFsdWUsIHIucHJldmlvdXNWYWx1ZSk7XHJcblxyXG4gICAgICAgIC8vIHVwZGF0ZSBwcm9wZXIgZGF0YSBvYmplY3QgZm9yIG5vZGUgb3IgbGlua1xyXG4gICAgICAgIGlmICghc2FtZVZhbHMpIHtcclxuICAgICAgICAgIHN3aXRjaCAoc3RyKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJuXCI6IHtcclxuICAgICAgICAgICAgICBsZXQgbSA9IGRpYS5tb2RlbDtcclxuICAgICAgICAgICAgICBsZXQga2V5UHJvcE5hbWUgPSBtLm5vZGVLZXlQcm9wZXJ0eS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgIHZhciBub2RlID0gZGlhLmZpbmROb2RlRm9yS2V5KHIucHJldmlvdXNWYWx1ZVtrZXlQcm9wTmFtZV0pO1xyXG4gICAgICAgICAgICAgIGlmIChub2RlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgZW50cnkgd2FzIHJlcGxhY2VkIHdpdGggbnVsbCBvciB1bmRlZmluZWQsIGp1c3QgcmVtb3ZlIHRoZSBlbnRyeSBhbHRvZ3RoZXJcclxuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgc3RpbGwgcHJldHR5IGJhZCBwcmFjdGljZSAtLSBpbnN0ZWFkLCB1c2VycyBzaG91bGQgcmVtb3ZlIGVudHJpZXMgaW4gdGhlaXIgbm9kZSAvIGxpbmsgLyBtb2RlbCBkYXRhLCBub3Qgc2V0IHRoZW0gdG8gbnVsbFxyXG4gICAgICAgICAgICAgICAgaWYgKCFyLmN1cnJlbnRWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICBkaWEucmVtb3ZlKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgZGlhLm1vZGVsLmFzc2lnbkFsbERhdGFQcm9wZXJ0aWVzKG5vZGUuZGF0YSwgci5jdXJyZW50VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIFwibFwiOiB7XHJcbiAgICAgICAgICAgICAgbGV0IG0gPSA8Z28uR3JhcGhMaW5rc01vZGVsPmRpYS5tb2RlbDtcclxuICAgICAgICAgICAgICB2YXIga2V5UHJvcE5hbWUgPSBtLmxpbmtLZXlQcm9wZXJ0eS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgIHZhciBsaW5rID0gZGlhLmZpbmRMaW5rRm9yS2V5KHIucHJldmlvdXNWYWx1ZVtrZXlQcm9wTmFtZV0pO1xyXG4gICAgICAgICAgICAgIGlmIChsaW5rKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgZW50cnkgd2FzIHJlcGxhY2VkIHdpdGggbnVsbCBvciB1bmRlZmluZWQsIGp1c3QgcmVtb3ZlIHRoZSBlbnRyeSBhbHRvZ3RoZXJcclxuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgc3RpbGwgcHJldHR5IGJhZCBwcmFjdGljZSAtLSBpbnN0ZWFkLCB1c2VycyBzaG91bGQgcmVtb3ZlIGVudHJpZXMgaW4gdGhlaXIgbm9kZSAvIGxpbmsgLyBtb2RlbCBkYXRhLCBub3Qgc2V0IHRoZW0gdG8gbnVsbFxyXG4gICAgICAgICAgICAgICAgaWYgKCFyLmN1cnJlbnRWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICBkaWEucmVtb3ZlKGxpbmspO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgZGlhLm1vZGVsLmFzc2lnbkFsbERhdGFQcm9wZXJ0aWVzKGxpbmsuZGF0YSwgci5jdXJyZW50VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFsd2F5cyBiZSBjaGVja2luZyBpZiBhcnJheSBJbnB1dCBkYXRhIGhhcyBjaGFuZ2VkIChub2RlIGFuZCBsaW5rIGRhdGEgYXJyYXlzKVxyXG4gICAqL1xyXG4gIHB1YmxpYyBuZ0RvQ2hlY2soKSB7XHJcblxyXG4gICAgaWYgKCF0aGlzLmRpYWdyYW0pIHJldHVybjtcclxuICAgIGlmICghdGhpcy5kaWFncmFtLm1vZGVsKSByZXR1cm47XHJcblxyXG4gICAgLy8gdGhlc2UgbmVlZCB0byBiZSBydW4gZWFjaCBjaGVjaywgZXZlbiBpZiBubyBtZXJnaW5nIGhhcHBlbnNcclxuICAgIC8vIG90aGVyd2lzZSwgdGhleSB3aWxsIGRldGVjdCBhbGwgZGlmZnMgdGhhdCBoYXBwZW5lZCBzaW5jZSBsYXN0IHRpbWUgc2tpcHNEaWFncmFtIHdhcyBmYWxzZSxcclxuICAgIC8vIHN1Y2ggYXMgcmVtb3ZlIG9wcyB0aGF0IGhhcHBlbmVkIGluIEdvSlMgd2hlbiBza2lwc0RpYWdyYW0gPSB0cnVlLCBcclxuICAgIC8vIGFuZCB0aGVuIHJlYWxsbGxsbHkgYmFkIHN0dWZmIGhhcHBlbnMgKGRlbGV0aW5nIHJhbmRvbSBub2RlcywgdXBkYXRpbmcgdGhlIHdyb25nIFBhcnRzKVxyXG4gICAgLy8gQW5ndWxhciBkaWZmZXJzIGFyZSBhIGxvdCBvZiBmdW5cclxuICAgIHZhciBub2RlRGlmZnMgPSB0aGlzLl9uZGFEaWZmZXIuZGlmZih0aGlzLm5vZGVEYXRhQXJyYXkpO1xyXG4gICAgdmFyIGxpbmtEaWZmcyA9IHRoaXMuX2xkYURpZmZlci5kaWZmKHRoaXMubGlua0RhdGFBcnJheSk7XHJcblxyXG4gICAgdmFyIG1vZGVsRGlmZnMgPSB0aGlzLl9tZGFEaWZmZXIuZGlmZih0aGlzLm1vZGVsRGF0YSk7XHJcblxyXG4gICAgaWYgKCFub2RlRGlmZnMgJiYgIWxpbmtEaWZmcyAmJiAhbW9kZWxEaWZmcykgcmV0dXJuO1xyXG5cclxuICAgIGlmICh0aGlzLnNraXBzRGlhZ3JhbVVwZGF0ZSkgcmV0dXJuO1xyXG5cclxuICAgIC8vIGRvbid0IG5lZWQgbW9kZWwgY2hhbmdlIGxpc3RlbmVyIHdoaWxlIHBlcmZvcm1pbmcga25vd24gZGF0YSB1cGRhdGVzXHJcbiAgICBpZiAodGhpcy5tb2RlbENoYW5nZWRMaXN0ZW5lciAhPT0gbnVsbCkgdGhpcy5kaWFncmFtLm1vZGVsLnJlbW92ZUNoYW5nZWRMaXN0ZW5lcih0aGlzLm1vZGVsQ2hhbmdlZExpc3RlbmVyKTtcclxuXHJcbiAgICB0aGlzLmRpYWdyYW0ubW9kZWwuc3RhcnRUcmFuc2FjdGlvbigndXBkYXRlIGRhdGEnKTtcclxuICAgIC8vIHVwZGF0ZSBtb2RlbERhdGEgZmlyc3QsIGluIGNhc2UgYmluZGluZ3Mgb24gbm9kZXMgLyBsaW5rcyBkZXBlbmQgb24gbW9kZWwgZGF0YVxyXG4gICAgdGhpcy5kaWFncmFtLm1vZGVsLmFzc2lnbkFsbERhdGFQcm9wZXJ0aWVzKHRoaXMuZGlhZ3JhbS5tb2RlbC5tb2RlbERhdGEsIHRoaXMubW9kZWxEYXRhKTtcclxuICAgIC8vIG1lcmdlIG5vZGUgLyBsaW5rIGRhdGFcclxuICAgIERpYWdyYW1Db21wb25lbnQubWVyZ2VDaGFuZ2VzKHRoaXMsIG5vZGVEaWZmcywgXCJuXCIpO1xyXG4gICAgRGlhZ3JhbUNvbXBvbmVudC5tZXJnZUNoYW5nZXModGhpcywgbGlua0RpZmZzLCBcImxcIik7XHJcbiAgICB0aGlzLmRpYWdyYW0ubW9kZWwuY29tbWl0VHJhbnNhY3Rpb24oJ3VwZGF0ZSBkYXRhJyk7XHJcblxyXG4gICAgLy8gcmVzZXQgdGhlIG1vZGVsIGNoYW5nZSBsaXN0ZW5lclxyXG4gICAgaWYgKHRoaXMubW9kZWxDaGFuZ2VkTGlzdGVuZXIgIT09IG51bGwpIHRoaXMuZGlhZ3JhbS5tb2RlbC5hZGRDaGFuZ2VkTGlzdGVuZXIodGhpcy5tb2RlbENoYW5nZWRMaXN0ZW5lcik7XHJcblxyXG4gIH0gLy8gZW5kIG5nRG9DaGVja1xyXG5cclxuICBwdWJsaWMgbmdPbkRlc3Ryb3koKSB7XHJcbiAgICB0aGlzLmRpYWdyYW0uZGl2ID0gbnVsbDsgLy8gcmVtb3ZlcyBldmVudCBsaXN0ZW5lcnNcclxuICB9XHJcbn1cclxuIl19